use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let package_name = env::var("CARGO_PKG_NAME").unwrap();
    let output_dir = target_dir().join("include");
    let header_file = output_dir.join(format!("{}.h", package_name));
    let config_file = output_dir.join("cbindgen.toml");

    // Create output directory
    std::fs::create_dir_all(&output_dir).expect("Failed to create include directory");

    // Generate cbindgen configuration for comprehensive C API
    let config_content = r#"
language = "C"
pragma_once = true
cpp_compat = true
include_version = true
sys_includes = ["stdint.h", "stdbool.h", "stddef.h", "unistd.h", "poll.h"]
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"

[export]
include = [
    # Core error handling and types
    "RenoirErrorCode", 
    "RenoirResult",
    "RenoirErrorInfo",
    
    # Handle types
    "RenoirManagerHandle", 
    "RenoirRegionHandle", 
    "RenoirBufferPoolHandle", 
    "RenoirTopicManagerHandle",
    "RenoirPublisherHandle", 
    "RenoirSubscriberHandle",
    "RenoirMessageHandle",
    "RenoirReservedBufferHandle",
    "RenoirReceivedMessageHandle",
    
    # ID and sequence types
    "RenoirTopicId",
    "RenoirSequenceNumber",
    
    # Configuration structures
    "RenoirRegionConfig",
    "RenoirBufferPoolConfig",
    "RenoirTopicOptions",
    "RenoirPublisherOptions", 
    "RenoirSubscriberOptions",
    
    # Message and metadata structures
    "RenoirMessageMetadata",
    "RenoirReceivedMessage",
    "RenoirBufferInfo",
    
    # Statistics structures
    "RenoirBufferPoolStats",
    "RenoirTopicStats",
    "RenoirRegionStats", 
    "RenoirTopicInfo",
    "RenoirRingStats",
    "RenoirMemoryStats",
    
    # Legacy large payloads support
    "BackingType", 
    "TopicPattern",
    "TopicManagerStats",
    "BlobHeader",
    "BlobDescriptor",
    "ChunkDescriptor", 
    "ROS2MessageType",
    "ImageHeader",
    "PointCloudHeader",
    "LaserScanHeader",
    "ReclamationStats"
]

[parse]
parse_deps = true
include = ["renoir"]

[defines]
"feature = c-api" = "RENOIR_C_API_ENABLED"
"target_os = linux" = "RENOIR_LINUX"
"feature = memfd" = "RENOIR_MEMFD_SUPPORT"
"#;

    std::fs::write(&config_file, config_content)
        .expect("Failed to write cbindgen configuration");

    // Generate C headers with enhanced configuration
    let builder = cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_language(cbindgen::Language::C)
        .with_pragma_once(true)
        .with_include_guard(format!("{}_H", package_name.to_uppercase()))
        .with_cpp_compat(true)
        .with_documentation(true)
        .with_parse_deps(true)
        .with_parse_include(&["renoir"])
        .with_sys_include("stdint.h")
        .with_sys_include("stdbool.h")
        .with_sys_include("stddef.h");

    // Only generate if c-api feature is enabled
    if cfg!(feature = "c-api") {
        builder
            .generate()
            .expect("Unable to generate C bindings")
            .write_to_file(&header_file);
        
        println!("cargo:rerun-if-changed=src/ffi/");
        println!("cargo:rerun-if-changed=src/large_payloads/");
        println!("Generated C headers: {}", header_file.display());
    }

    // Generate additional ROS2-specific headers
    generate_ros2_integration_headers(&output_dir);

    // Print build information
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/");
    println!("cargo:rustc-env=RENOIR_BUILD_INFO=Built with large payloads support");
}

/// Generate ROS2-specific integration headers and examples
fn generate_ros2_integration_headers(output_dir: &PathBuf) {
    let ros2_header = output_dir.join("renoir_ros2.h");
    let integration_example = output_dir.join("renoir_usage_example.c");
    
    let ros2_content = r#"
/**
 * @file renoir_ros2.h
 * @brief ROS2 integration utilities for Renoir shared memory
 * 
 * This header provides convenience macros and type definitions specifically
 * for integrating Renoir with ROS2 systems.
 */

#ifndef RENOIR_ROS2_H
#define RENOIR_ROS2_H

#include "renoir.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ROS2 Message Type Constants */
#define RENOIR_ROS2_IMAGE_RAW           0
#define RENOIR_ROS2_IMAGE_COMPRESSED    1
#define RENOIR_ROS2_POINTCLOUD2         2
#define RENOIR_ROS2_LASERSCAN           3

/* Common ROS2 Buffer Sizes */
#define RENOIR_ROS2_SMALL_BUFFER_SIZE   (4 * 1024)     /* 4KB for headers, small messages */
#define RENOIR_ROS2_MEDIUM_BUFFER_SIZE  (64 * 1024)    /* 64KB for moderate data */
#define RENOIR_ROS2_LARGE_BUFFER_SIZE   (1024 * 1024)  /* 1MB for images, point clouds */
#define RENOIR_ROS2_HUGE_BUFFER_SIZE    (16 * 1024 * 1024) /* 16MB for very large payloads */

/* Recommended Pool Configurations for ROS2 */
#define RENOIR_ROS2_SMALL_POOL_COUNT    100
#define RENOIR_ROS2_MEDIUM_POOL_COUNT   50
#define RENOIR_ROS2_LARGE_POOL_COUNT    20
#define RENOIR_ROS2_HUGE_POOL_COUNT     5

/* Helper macros for ROS2 integration */
#define RENOIR_ROS2_CREATE_IMAGE_POOL(manager, region_name) \
    renoir_buffer_pool_create(manager, region_name, "ros2_images", \
                             RENOIR_ROS2_LARGE_BUFFER_SIZE, \
                             RENOIR_ROS2_LARGE_POOL_COUNT, 64, true, 100)

#define RENOIR_ROS2_CREATE_POINTCLOUD_POOL(manager, region_name) \
    renoir_buffer_pool_create(manager, region_name, "ros2_pointclouds", \
                             RENOIR_ROS2_HUGE_BUFFER_SIZE, \
                             RENOIR_ROS2_HUGE_POOL_COUNT, 64, true, 500)

#ifdef __cplusplus
}
#endif

#endif /* RENOIR_ROS2_H */
"#;

    let example_content = r#"
/**
 * @file renoir_usage_example.c
 * @brief Example usage of Renoir C API with large payloads
 */

#include "renoir.h"
#include "renoir_ros2.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    printf("Renoir C API Example - Large Payloads\n");
    printf("=====================================\n");
    
    /* Create manager */
    RenoirManagerHandle manager = renoir_manager_create();
    if (manager == NULL) {
        fprintf(stderr, "Failed to create manager\n");
        return 1;
    }
    
    /* Create region for large payloads */
    RenoirRegionHandle region;
    RenoirErrorCode result = renoir_region_create(
        manager, "example_region", 64 * 1024 * 1024, /* 64MB */
        BACKING_TYPE_FILE_BACKED, "/tmp/renoir_example", &region
    );
    
    if (result != RENOIR_SUCCESS) {
        fprintf(stderr, "Failed to create region\n");
        renoir_manager_destroy(manager);
        return 1;
    }
    
    /* Create buffer pool for ROS2 images */
    RenoirBufferPoolHandle pool = RENOIR_ROS2_CREATE_IMAGE_POOL(manager, "example_region");
    if (pool == NULL) {
        fprintf(stderr, "Failed to create buffer pool\n");
        renoir_manager_destroy(manager);
        return 1;
    }
    
    printf("✓ Created shared memory region and buffer pool\n");
    printf("✓ Ready for ROS2 large payload processing\n");
    
    /* Cleanup */
    renoir_buffer_pool_destroy(pool);
    renoir_manager_destroy(manager);
    
    return 0;
}
"#;

    let comprehensive_example = output_dir.join("comprehensive_example.c");
    let comprehensive_content = r#"
/*
 * Comprehensive Renoir C API Example
 * Demonstrates all major API features
 */

#include "renoir.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main() {
    printf("=== Comprehensive Renoir API Example ===\n");
    
    /* 1. Create Manager and Region */
    RenoirManagerHandle manager = renoir_manager_create();
    if (manager == NULL) {
        fprintf(stderr, "Failed to create manager\n");
        return 1;
    }
    
    RenoirRegionConfig region_config = {
        .name = "test_region",
        .size = 64 * 1024 * 1024, /* 64MB */
        .backing_type = 1, /* MemFd */
        .file_path = NULL,
        .create = true,
        .permissions = 0600
    };
    
    RenoirRegionHandle region;
    RenoirErrorCode result = renoir_region_create(manager, &region_config, &region);
    if (result != RENOIR_SUCCESS) {
        fprintf(stderr, "Failed to create region: %s\n", renoir_strerror(result));
        renoir_manager_destroy(manager);
        return 1;
    }
    printf("✓ Created shared memory region\n");
    
    /* 2. Create Topic Manager and Register Topic */
    RenoirTopicManagerHandle topic_manager = renoir_topic_manager_create();
    if (topic_manager == NULL) {
        fprintf(stderr, "Failed to create topic manager\n");
        return 1;
    }
    
    RenoirTopicOptions topic_opts = {
        .pattern = 0, /* SPSC */
        .ring_capacity = 64,
        .max_payload_size = 1024 * 1024,
        .use_shared_pool = true,
        .shared_pool_threshold = 4096,
        .enable_notifications = true
    };
    
    RenoirTopicId topic_id;
    result = renoir_topic_register(topic_manager, region, "/test/topic", &topic_opts, &topic_id);
    if (result != RENOIR_SUCCESS) {
        fprintf(stderr, "Failed to register topic: %s\n", renoir_strerror(result));
        return 1;
    }
    printf("✓ Registered topic with ID: %lu\n", topic_id);
    
    /* 3. Create Publisher and Subscriber */
    RenoirPublisherOptions pub_opts = {
        .batch_size = 1,
        .timeout_ms = 1000,
        .priority = 0,
        .enable_batching = false
    };
    
    RenoirPublisherHandle publisher;
    result = renoir_publisher_create_enhanced(topic_manager, topic_id, &pub_opts, &publisher);
    if (result != RENOIR_SUCCESS) {
        fprintf(stderr, "Failed to create publisher: %s\n", renoir_strerror(result));
        return 1;
    }
    
    RenoirSubscriberOptions sub_opts = {
        .mode = 1, /* non-blocking */
        .batch_size = 1,
        .timeout_ms = 100,
        .queue_depth = 64,
        .enable_filtering = false
    };
    
    RenoirSubscriberHandle subscriber;
    result = renoir_subscriber_create_enhanced(topic_manager, topic_id, &sub_opts, &subscriber);
    if (result != RENOIR_SUCCESS) {
        fprintf(stderr, "Failed to create subscriber: %s\n", renoir_strerror(result));
        return 1;
    }
    printf("✓ Created publisher and subscriber\n");
    
    /* 4. Publish Messages */
    const char* test_message = "Hello from Renoir C API!";
    size_t message_len = strlen(test_message);
    
    RenoirMessageMetadata metadata = {
        .timestamp_ns = 1234567890,
        .sequence_number = 0,
        .source_id = 1,
        .message_type = 0,
        .flags = 0
    };
    
    RenoirSequenceNumber seq_num;
    result = renoir_publish_with_metadata(publisher, (const uint8_t*)test_message, 
                                        message_len, &metadata, &seq_num);
    if (result != RENOIR_SUCCESS) {
        fprintf(stderr, "Failed to publish message: %s\n", renoir_strerror(result));
        return 1;
    }
    printf("✓ Published message with sequence number: %lu\n", seq_num);
    
    /* 5. Zero-Copy Publishing */
    uint8_t* buffer_ptr;
    RenoirReservedBufferHandle reserved_handle;
    result = renoir_publish_reserve(publisher, 1024, &buffer_ptr, &reserved_handle);
    if (result == RENOIR_SUCCESS) {
        strcpy((char*)buffer_ptr, "Zero-copy message!");
        size_t actual_len = strlen((char*)buffer_ptr);
        
        result = renoir_publish_commit(publisher, reserved_handle, actual_len, &seq_num);
        if (result == RENOIR_SUCCESS) {
            printf("✓ Published zero-copy message with sequence: %lu\n", seq_num);
        }
    }
    
    /* 6. Receive Messages */
    RenoirReceivedMessage received_msg;
    result = renoir_read_next(subscriber, &received_msg, 1000); /* 1s timeout */
    if (result == RENOIR_SUCCESS) {
        printf("✓ Received message: %.*s (seq: %lu)\n", 
               (int)received_msg.payload_len, 
               (char*)received_msg.payload_ptr,
               received_msg.metadata.sequence_number);
        
        /* Release the message */
        renoir_message_release(received_msg.handle);
    }
    
    /* 7. Get Statistics */
    RenoirTopicStats topic_stats;
    result = renoir_topic_stats(topic_manager, topic_id, &topic_stats);
    if (result == RENOIR_SUCCESS) {
        printf("✓ Topic stats: %lu published, %lu consumed\n",
               topic_stats.messages_published, topic_stats.messages_consumed);
    }
    
    /* 8. System Health Check */
    double health_score;
    uint32_t issues;
    result = renoir_health_check(&health_score, &issues);
    if (result == RENOIR_SUCCESS) {
        printf("✓ System health score: %.1f%%, issues: 0x%x\n", health_score, issues);
    }
    
    /* 9. List All Topics */
    RenoirTopicInfo* topics;
    size_t topic_count;
    result = renoir_list_topics(topic_manager, &topics, &topic_count);
    if (result == RENOIR_SUCCESS) {
        printf("✓ Found %zu topics:\n", topic_count);
        for (size_t i = 0; i < topic_count; i++) {
            printf("  - %s (ID: %lu, publishers: %zu)\n", 
                   topics[i].name, topics[i].topic_id, topics[i].publisher_count);
        }
        renoir_free_topics_list(topics, topic_count);
    }
    
    /* 10. Cleanup */
    renoir_publisher_destroy(publisher);
    renoir_subscriber_destroy(subscriber);
    renoir_topic_manager_destroy(topic_manager);
    renoir_region_close(region);
    renoir_manager_destroy(manager);
    
    printf("✓ All operations completed successfully!\n");
    return 0;
}
"#;

    // Write the files
    std::fs::write(&ros2_header, ros2_content).ok();
    std::fs::write(&integration_example, example_content).ok();
    std::fs::write(&comprehensive_example, comprehensive_content).ok();
}

fn target_dir() -> PathBuf {
    if let Ok(target) = env::var("CARGO_TARGET_DIR") {
        PathBuf::from(target)
    } else {
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join("target")
    }
}