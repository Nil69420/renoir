use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let package_name = env::var("CARGO_PKG_NAME").unwrap();
    let output_dir = target_dir().join("include");
    let header_file = output_dir.join(format!("{}.h", package_name));
    let config_file = output_dir.join("cbindgen.toml");

    // Create output directory
    std::fs::create_dir_all(&output_dir).expect("Failed to create include directory");

    // Generate cbindgen configuration for comprehensive C API
    let config_content = r#"
language = "C"
pragma_once = true
cpp_compat = true
include_version = true
sys_includes = ["stdint.h", "stdbool.h", "stddef.h"]
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"

[export]
include = [
    "RenoirErrorCode", 
    "RenoirResult",
    "RenoirManagerHandle", 
    "RenoirRegionHandle", 
    "RenoirBufferPoolHandle", 
    "RenoirTopicManagerHandle",
    "RenoirPublisherHandle", 
    "RenoirSubscriberHandle",
    "BackingType", 
    "TopicPattern",
    "BufferPoolStats", 
    "TopicManagerStats",
    "BlobHeader",
    "BlobDescriptor",
    "ChunkDescriptor", 
    "ROS2MessageType",
    "ImageHeader",
    "PointCloudHeader",
    "LaserScanHeader",
    "ReclamationStats"
]

[parse]
parse_deps = true
include = ["renoir"]

[defines]
"feature = c-api" = "RENOIR_C_API_ENABLED"
"target_os = linux" = "RENOIR_LINUX"
"feature = memfd" = "RENOIR_MEMFD_SUPPORT"
"#;

    std::fs::write(&config_file, config_content)
        .expect("Failed to write cbindgen configuration");

    // Generate C headers with enhanced configuration
    let builder = cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_language(cbindgen::Language::C)
        .with_pragma_once(true)
        .with_include_guard(format!("{}_H", package_name.to_uppercase()))
        .with_cpp_compat(true)
        .with_documentation(true)
        .with_parse_deps(true)
        .with_parse_include(&["renoir"])
        .with_sys_include("stdint.h")
        .with_sys_include("stdbool.h")
        .with_sys_include("stddef.h");

    // Only generate if c-api feature is enabled
    if cfg!(feature = "c-api") {
        builder
            .generate()
            .expect("Unable to generate C bindings")
            .write_to_file(&header_file);
        
        println!("cargo:rerun-if-changed=src/ffi/");
        println!("cargo:rerun-if-changed=src/large_payloads/");
        println!("Generated C headers: {}", header_file.display());
    }

    // Generate additional ROS2-specific headers
    generate_ros2_integration_headers(&output_dir);

    // Print build information
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/");
    println!("cargo:rustc-env=RENOIR_BUILD_INFO=Built with large payloads support");
}

/// Generate ROS2-specific integration headers and examples
fn generate_ros2_integration_headers(output_dir: &PathBuf) {
    let ros2_header = output_dir.join("renoir_ros2.h");
    let integration_example = output_dir.join("renoir_usage_example.c");
    
    let ros2_content = r#"
/**
 * @file renoir_ros2.h
 * @brief ROS2 integration utilities for Renoir shared memory
 * 
 * This header provides convenience macros and type definitions specifically
 * for integrating Renoir with ROS2 systems.
 */

#ifndef RENOIR_ROS2_H
#define RENOIR_ROS2_H

#include "renoir.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ROS2 Message Type Constants */
#define RENOIR_ROS2_IMAGE_RAW           0
#define RENOIR_ROS2_IMAGE_COMPRESSED    1
#define RENOIR_ROS2_POINTCLOUD2         2
#define RENOIR_ROS2_LASERSCAN           3

/* Common ROS2 Buffer Sizes */
#define RENOIR_ROS2_SMALL_BUFFER_SIZE   (4 * 1024)     /* 4KB for headers, small messages */
#define RENOIR_ROS2_MEDIUM_BUFFER_SIZE  (64 * 1024)    /* 64KB for moderate data */
#define RENOIR_ROS2_LARGE_BUFFER_SIZE   (1024 * 1024)  /* 1MB for images, point clouds */
#define RENOIR_ROS2_HUGE_BUFFER_SIZE    (16 * 1024 * 1024) /* 16MB for very large payloads */

/* Recommended Pool Configurations for ROS2 */
#define RENOIR_ROS2_SMALL_POOL_COUNT    100
#define RENOIR_ROS2_MEDIUM_POOL_COUNT   50
#define RENOIR_ROS2_LARGE_POOL_COUNT    20
#define RENOIR_ROS2_HUGE_POOL_COUNT     5

/* Helper macros for ROS2 integration */
#define RENOIR_ROS2_CREATE_IMAGE_POOL(manager, region_name) \
    renoir_buffer_pool_create(manager, region_name, "ros2_images", \
                             RENOIR_ROS2_LARGE_BUFFER_SIZE, \
                             RENOIR_ROS2_LARGE_POOL_COUNT, 64, true, 100)

#define RENOIR_ROS2_CREATE_POINTCLOUD_POOL(manager, region_name) \
    renoir_buffer_pool_create(manager, region_name, "ros2_pointclouds", \
                             RENOIR_ROS2_HUGE_BUFFER_SIZE, \
                             RENOIR_ROS2_HUGE_POOL_COUNT, 64, true, 500)

#ifdef __cplusplus
}
#endif

#endif /* RENOIR_ROS2_H */
"#;

    let example_content = r#"
/**
 * @file renoir_usage_example.c
 * @brief Example usage of Renoir C API with large payloads
 */

#include "renoir.h"
#include "renoir_ros2.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    printf("Renoir C API Example - Large Payloads\n");
    printf("=====================================\n");
    
    /* Create manager */
    RenoirManagerHandle manager = renoir_manager_create();
    if (manager == NULL) {
        fprintf(stderr, "Failed to create manager\n");
        return 1;
    }
    
    /* Create region for large payloads */
    RenoirRegionHandle region;
    RenoirErrorCode result = renoir_region_create(
        manager, "example_region", 64 * 1024 * 1024, /* 64MB */
        BACKING_TYPE_FILE_BACKED, "/tmp/renoir_example", &region
    );
    
    if (result != RENOIR_SUCCESS) {
        fprintf(stderr, "Failed to create region\n");
        renoir_manager_destroy(manager);
        return 1;
    }
    
    /* Create buffer pool for ROS2 images */
    RenoirBufferPoolHandle pool = RENOIR_ROS2_CREATE_IMAGE_POOL(manager, "example_region");
    if (pool == NULL) {
        fprintf(stderr, "Failed to create buffer pool\n");
        renoir_manager_destroy(manager);
        return 1;
    }
    
    printf("✓ Created shared memory region and buffer pool\n");
    printf("✓ Ready for ROS2 large payload processing\n");
    
    /* Cleanup */
    renoir_buffer_pool_destroy(pool);
    renoir_manager_destroy(manager);
    
    return 0;
}
"#;

    // Write the files
    std::fs::write(&ros2_header, ros2_content).ok();
    std::fs::write(&integration_example, example_content).ok();
}

fn target_dir() -> PathBuf {
    if let Ok(target) = env::var("CARGO_TARGET_DIR") {
        PathBuf::from(target)
    } else {
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join("target")
    }
}